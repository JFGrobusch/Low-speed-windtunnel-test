Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#!/usr/bin/env python3\r\n# -*- coding: utf-8 -*-\r\n\"\"\"\r\nCreated on Sun Dec 13 18:12:15 2020\r\n\r\nretrieve streamline procession\r\n\r\ntest images saved in test directory\r\n\r\nmodification pending\r\n\r\n@author: jangrobusch\r\n\"\"\"\r\n\r\nfrom tools import getarray, savearray\r\nimport numpy as np\r\nfrom statistics import mean\r\n\r\nclass datapoint():\r\n    def __init__(self, angle, dim):\r\n        self.dim = dim #dimension (2d or 3d)\r\n        self.name = angle #AoA (deg)\r\n        self.AoA = float(self.name.replace('b','')) #for eventual plotting; removes non float character\r\n        if 'b' in self.name: self.back = True #stores whether or not data point belongs to hysteresis\r\n        else: self.back = False\r\n        self.precession = None #initially empty; eventually procession value (%) will be stored here\r\n\r\ndef getprecession(datapoint):\r\n    \r\n    print(\"Generating difference array for\", datapoint.name, \"deg AoA\", datapoint.dim, \"case\")\r\n    array = getarray(datapoint.name, datapoint.dim) #initialise array\r\n    crop = 80 #number of pixels removed from top and bottom of image (crop). number hard coded\r\n    array = array[crop:array.shape[0]-crop] #crops array to desired dimension\r\n    \r\n    reach = 10 #reach concerns the number of pixels considered in positive and negative direction\r\n    diffarray = np.zeros_like(array) #copies initial array to new array for modification\r\n    \r\n    #generates new array composed of the difference between the average of 30 preceding and following entries\r\n    \r\n    def avgdiff(row): #considers [reach] entries preceding and following points in the row to find average of entries\r\n        #diffrow array has max value 255 min value 0 and all int; low level of fineness recorded. consider converting array to floats, this will slow down calcs\r\n        index = 0\r\n        diffrow = np.zeros_like(row) #gen empty array to write to\r\n        for entry in row:\r\n            low = index-reach\r\n            if low < 0: low = 0 #prevent index error (negartive values not valid)\r\n            high = index+reach+1\r\n            preceding_points = row[low:index]\r\n            following_points = row[index+1:high] #get points before and after point\r\n            avg_pre = np.mean(preceding_points)\r\n            avg_follow = np.mean(following_points) #get averages\r\n            if preceding_points.size < 10 or following_points.size < 10: np.put(diffrow, index, 0) #check that array is suitably large (avoid noise)\r\n            else: np.put(diffrow, index, abs(avg_pre-avg_follow))    #returns diffrow; only int are recorded, floats are unnecessarily slow           \r\n            index += 1\r\n        return(diffrow)\r\n    index = 0\r\n    for row in array:\r\n        diffarray[index] = avgdiff(row)#gets diffrow, writes to np row\r\n        index += 1 \r\n            \r\n    #refine edges; narrow down to one leading edge, one trailing edge, and transition.\r\n                \r\n    def processrow(row): #gets max value within row; sets all non-max values within reach to 0. Similar procedure 2 more times\r\n        foil_edge_1 = np.argmax(row) #get index of max\r\n        row[foil_edge_1-reach: foil_edge_1+reach+1]=0 #sets midpoint values+range to 0          #index error might occur, fix if necessary\r\n        foil_edge_2 = np.argmax(row) #get index of 2nd max\r\n        row[foil_edge_2-reach: foil_edge_2+reach+1]=0 #sets midpoint values+range to 0 for 2nd edge\r\n        \r\n        likely_transition = np.argmax(row) #likely transition point is remaining maximum\r\n        \r\n        trailing_edge = min(foil_edge_1, foil_edge_2) #gets trailing edge\r\n        leading_edge = max(foil_edge_1, foil_edge_2) #gets leading edge\r\n        chord = leading_edge-trailing_edge #chord length in px\r\n        prc = abs(likely_transition-trailing_edge) #distance from transition to trailing edge in px\r\n        \r\n        transition_pc = prc/chord*100 #percentage procession of chord\r\n        return(transition_pc)\r\n        \r\n    transition_points = [] #empty list to store transition points\r\n    for row in diffarray:\r\n        transition_points.append(processrow(row))\r\n    datapoint.precession = mean(transition_points)\r\n    print(datapoint.name, datapoint.dim,\" has turbulent transition at\", round(datapoint.precession) , \"% chord\")           \r\n    return()\r\n\r\np1 = datapoint(\"11\", \"2D\")\r\n\r\ngetprecession(p1)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 999da797cb8b2f8d3baa9ab6ef04644be541ad26)
+++ b/main.py	(date 1608031603055)
@@ -16,7 +16,8 @@
 import numpy as np
 from statistics import mean
 
-class datapoint():
+
+class Datapoint():
     def __init__(self, angle, dim):
         self.dim = dim #dimension (2d or 3d)
         self.name = angle #AoA (deg)
@@ -25,7 +26,8 @@
         else: self.back = False
         self.precession = None #initially empty; eventually procession value (%) will be stored here
 
-def getprecession(datapoint):
+
+def get_precession(datapoint):
     
     print("Generating difference array for", datapoint.name, "deg AoA", datapoint.dim, "case")
     array = getarray(datapoint.name, datapoint.dim) #initialise array
@@ -83,6 +85,6 @@
     print(datapoint.name, datapoint.dim," has turbulent transition at", round(datapoint.precession) , "% chord")           
     return()
 
-p1 = datapoint("11", "2D")
+p1 = Datapoint("11", "2D")
 
-getprecession(p1)
\ No newline at end of file
+get_precession(p1)
\ No newline at end of file
